"""
bnf_grmr

Reads a BNF grammar file and imports the values into a BNF instance.

Contains the BNF_Filereader class.
"""
from .bnf import BNF

class BNF_Filereader:
    """
    BNF_Filereader

    Reads a grmr file in BNF (specified by "BNF" on first line)
    that is imported into a BNF instance generated by this class.

    One instance per file.

    Methods:
    - TODO

    Variables:
    - TODO
    """
    def __init__(self, filename):
        with open(filename) as f:
            self.lines = f.readlines()
        self.bnf = BNF()


    def preprocess_line(self, line):
        sLine = line.strip()
        if sLine[0:2] == '//':
            return ()
        sLine.replace('\r', ' ')
        sLine.replace('\t', ' ')
        while '  ' in sLine:
            sLine.replace('  ', ' ')
        words = sLine.split(' ')
        return words


    def is_symbol_terminal(self, word):
        if len(word) < 2:
            return False
        if word[0] == '"' and word[-1] == '"':
            return True
        return False


    def is_symbol_intermediate(self, word):
        if len(word) < 2:
            return False
        if word[0] == '<' and word[-1] == '>':
            return True
        return False


    def get_rhs_alternatives(self, rhs):
        words = [[]]
        for word in rhs:
            if word == '|':
                words.append([])
            else:
                words[-1].append(word)
        return words


    def split_tuple(self, tuple, splitpoint):
        ret = [[]]
        split_id = 0
        for value in tuple:
            if value == splitpoint:
                split_id += 1
                ret.append([])
            else:
                ret[split_id].append(value)
        return ret


    def decode_values_in_tuple(self, tuple):
        ret = []
        for item in tuple:
            ret.append(item[1:-1])
        return ret


    def process_lines(self):
        for line in self.lines[1:]:
            preprocessed_line = self.preprocess_line(line)
            if len(preprocessed_line) > 1:
                split = self.split_tuple(preprocessed_line, '::=')
                lhs = split[0][0]
                rhs = split[1]
                rhs_split = self.get_rhs_alternatives(rhs)
                for alternative in rhs_split:
                    decoded_alternative = self.decode_values_in_tuple(alternative)
                    for symbol in alternative:
                        if symbol[1:-1] not in self.bnf.symbols:
                            self.bnf.add_symbol(symbol[1:-1], self.is_symbol_terminal(symbol))
                    if lhs[1:-1] not in self.bnf.symbols:
                        self.bnf.add_symbol(symbol[1:-1], is_terminal=False)
                    if lhs == '*':
                        self.bnf.add_rule_to_root(*decoded_alternative)
                    else:
                        self.bnf.add_rule(lhs[1:-1], *decoded_alternative)
        return self.bnf
